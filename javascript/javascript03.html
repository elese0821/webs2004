<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 불러오기</title>
    <link rel="stylesheet" href="https://webfontworld.github.io/gmarket/GmarketSans.css">
    <link rel="stylesheet" href="https://websfont.github.io/nanumSquareNeo/nanumSquareNeo.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="../assets/css/default.min.css">
</head>

<body>
    <div id="wrap">
        <header id="header">
            <h1><a href="index.html">javascript</a></h1>
            <nav>
                <ul>
                    <li><a href="javascript01.html">데이터 저장하기</a></li>
                    <li><a href="javascript02.html">데이터 불러오기</a></li>
                    <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                    <li><a href="javascript04.html">데이터 제어하기</a></li>
                </ul>
                <ul>
                    <li><a href="javascript05.html">문자열 객체</a></li>
                    <li><a href="javascript06.html">배열 객체</a></li>
                    <li><a href="javascript07.html">수학 객체</a></li>
                    <li><a href="javascript08.html">브라우저 객체</a></li>
                    <li><a href="javascript09.html">요소 객체</a></li>
                    <li><a href="javascript10.html">이벤트 객체</a></li>
                </ul>
                <ul>
                    <li><a href="javascript11.html">데이터 효과</a></li>
                    <li><a href="javascript12.html">퀴즈 효과</a></li>
                    <li><a href="javascript13.html">마우스 효과</a></li>
                    <li><a href="javascript14.html">슬라이드 효과</a></li>
                </ul>
            </nav>
        </header>
        <!-- //header -->

        <main id="main">
            <div class="main__menu">
                <ul>
                    <li><a href="#sample01">01. 함수 : 선언적 함수</a></li>
                    <li><a href="#sample02">02. 함수 : 익명 함수</a></li>
                    <li><a href="#sample03">03. 함수 : 매개변수 함수</a></li>
                    <li><a href="#sample04">04. 함수 : 리턴값 함수</a></li>
                    <li><a href="#sample05">05. 함수 : 매개변수 + 리턴값 함수</a></li>
                    <li><a href="#sample06">06. 화살표 함수 : 선언적 함수</a></li>
                    <li><a href="#sample07">07. 화살표 함수 : 익명 함수</a></li>
                    <li><a href="#sample08">08. 화살표 함수 : 매개변수 함수</a></li>
                    <li><a href="#sample09">09. 화살표 함수 : 리턴값 함수</a></li>
                    <li><a href="#sample10">10. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값</a></li>
                    <li><a href="#sample11">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                    <li><a href="#sample12">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                    <li><a href="#sample13">13. 함수 유형 : 함수와 배열을 이용한 형태</a></li>
                    <li><a href="#sample14">14. 함수 유형 : 함수와 객체를 이용한 형태</a></li>
                    <li><a href="#sample15">15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</a></li>
                    <li><a href="#sample16">16. 함수 유형 : 객체 안에 함수를 이용한 형태</a></li>
                    <li><a href="#sample17">17. 함수 유형 : 객체 생성자 함수</a></li>
                    <li><a href="#sample18">18. 함수 유형 : 프로토타입 함수</a></li>
                    <li><a href="#sample19">19. 함수 유형 : 객체 리터럴 함수</a></li>
                    <li><a href="#sample20">20. 함수 : 즉시실행 함수</a></li>
                    <li><a href="#sample21">21. 함수 : 파라미터 함수</a></li>
                    <li><a href="#sample22">22. 함수 : 재귀 함수</a></li>
                    <li><a href="#sample23">23. 함수 : 콜백 함수</a></li>
                    <li><a href="#sample24">24. 함수 : 비동기 함수 : 콜백 함수</a></li>
                    <li><a href="#sample25">25. 함수 : 비동기 함수 : 프로미스</a></li>
                    <li><a href="#sample26">26. 함수 : 비동기 함수 : asyne/await</a></li>
                    <li><a href="#sample27">27. 함수 : 중첩 함수</a></li>
                    <li><a href="#sample28">28. 함수 : 클로저</a></li>
                    <li><a href="#sample29">29. 클래스 : 기본</a></li>
                    <li><a href="#sample30">30. 클래스 : 상속</a></li>
                </ul>
            </div>
            <!-- //main__menu -->

            <div class="main__sample">
                <div id="sample01" class="sample">
                    <h3>01. 함수 : 선언적 함수</h3>
                    <p>자바스크립트(JavaScript)에서 함수는 프로그램 내에서 재사용 가능한 코드 블록을 나타내는 중요한 개념입니다.
                        함수를 사용하면 특정 작업을 수행하는 코드를 논리적으로 묶어서 호출하고 실행할 수 있습니다.
                        이를 통해 코드의 재사용성을 증가시키고 유지보수를 용이하게 만들 수 있습니다. 함수는 자체 스코프 내에서 변수를 선언하고,
                        매개변수를 통해 입력을 받아 작업을 수행하며, 결과를 반환할 수 있습니다.</p>
                    <pre><code class="language-js">{
        function func(){
            var x = 100;
            var y = 200;
            var z = "javascript";
            
            console.log(x);
            console.log(y);
            console.log(z);
            }
            func();
}
</code></pre>
                    <p class="desc">함수 선언은 function 키워드를 사용하여 함수를 정의하는 것을 말합니다. 함수 선언을 통해 함수의 이름, 매개변수(parameter), 함수 본문
                        등을 정의하고 해당 함수를 호출할 수 있습니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                200<br>
                                javascript
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple01 -->
                <div id="sample02" class="sample">
                    <h3>02. 함수 : 익명 함수</h3>
                    <p>자바스크립트에서 익명 함수(Anonymous Function)는 이름이 없는 함수를 말합니다.
                        익명 함수는 주로 함수 표현식으로 사용되며, 다른 함수의 인수로 전달되거나 변수에 할당되는 등의 상황에서 활용됩니다.
                        익명 함수는 함수 선언과 마찬가지로 함수의 기능을 정의하고 호출할 수 있습니다.</p>
                    <pre><code class="language-js">{
        const func = function (){
            let x = 100;
            let y = 200;
            let z = "javascript";

            console.log(x);
            console.log(y);
            console.log(z);
        };
        func();
}
</code></pre>
                    <p class="desc">익명 함수는 주로 함수 표현식과 함께 사용됩니다. 함수 표현식은 변수에 함수를 할당하는 것을 의미하며, 변수를 통해 익명 함수를 참조하고 호출할 수
                        있습니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                200<br>
                                javascript
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple02 -->
                <div id="sample03" class="sample">
                    <h3>03. 매개변수 함수</h3>
                    <p>자바스크립트에서 함수의 매개변수는 함수가 호출될 때 전달되는 값을 받는 변수입니다. 함수의 매개변수를 사용하여 함수 내부에서 작업을 수행하거나 계산을 수행할 때 필요한
                        데이터를 전달할 수 있습니다. 매개변수는 함수 정의 시 괄호 안에 나열되며, 함수가 호출될 때 전달되는 값들은 해당 매개변수에 할당됩니다.</p>
                    <pre><code class="language-js">{
        function func(x, y, z){
            console.log(x);
            console.log(y);
            console.log(z);
        }
        func(100, 200, "javascript");
    }
    {
        const func = function (x,y,z){
            console.log(x);
            console.log(y);
            console.log(z);
        }//익명함수
        func(100, 200, "javascript");
}
</code></pre>
                    <p class="desc">함수 내에서 매개변수는 일반적인 변수처럼 사용될 수 있으며, 함수 내부에서 값을 읽거나 수정할 수 있습니다. 이 때 매개변수는 함수 외부의 변수들과
                        독립적인 스코프를 가지며, 함수 내부에서만 접근 가능합니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                200<br>
                                javascript<br>
                                100<br>
                                200<br>
                                javascript
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple03 -->
                <div id="sample04" class="sample">
                    <h3>04. 리턴값 함수</h3>
                    <p>자바스크립트에서 함수의 매개변수는 함수가 호출될 때 전달되는 값을 받는 변수입니다. 함수의 매개변수를 사용하여 함수 내부에서 작업을 수행하거나 계산을 수행할 때 필요한
                        데이터를 전달할 수 있습니다. 매개변수는 함수 정의 시 괄호 안에 나열되며, 함수가 호출될 때 전달되는 값들은 해당 매개변수에 할당됩니다.</p>
                    <pre><code class="language-js">{
    {
        function func(){
            const x = 100;
            const y = 200;
            const z = "javascript";
            return y + x;
        }
        console.log(func());
    }
    {
        const func1 = function (){
            const x = 100;
            const y = 200;
            const z = "javascript";

            return y + x;
        }
        console.log(func1());
    }
}
</code></pre>
                    <p class="desc">리턴값(결과/종료)이 있는 함수는 return 제어문을 사용해서 함수의 연산 결과 중 원하는 값을 지정해서 호출위치로 복구시키는 기능을 말합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                300<br>
                                300
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple04 -->
                <div id="sample05" class="sample">
                    <h3>05. 함수 : 매개변수 + 리턴값 함수</h3>
                    <p>매개변수를 받아서 처리하고 결과 값을 반환하는 함수 예제</p>
                    <pre><code class="language-js">{
        function func(x){
            return x
        };
        console.log(func(100));

        const func1 = function(x){
            return x
        };
        console.log(func1(100));
}
</code></pre>
                    <p class="desc">이 예제에서 func 함수는 x라는 매개변수를 받습니다. 함수 본문에서는 x를 func 변수에 저장한 후, return 키워드를 사용하여 계산된 결과
                        값을 반환합니다. 함수를 호출할 때는 함수 이름 뒤에 괄호를 사용하고, 매개변수로 전달하고자 하는 값을 전달합니다. 호출 결과로 함수가 실행되고, 결과 값이 반환됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                100
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple05 -->
                <div id="sample06" class="sample">
                    <h3>06. 화살표 함수 : 선언적 함수</h3>
                    <p>JavaScript에서는 화살표 함수(arrow function)라는 간결한 함수 표현식을 제공하여 함수를 선언할 수 있습니다. 화살표 함수는 함수를 더 간결하게 작성할 수
                        있도록 도와주며, 주로 익명 함수로 사용되거나 간단한 로직을 처리할 때 유용합니다.</p>
                    <pre><code class="language-js">{
        function func(x){
            return x
        };
        console.log(func(100));

        const func1 = function(x){
            return x
        };
        console.log(func1(100));
}
</code></pre>
                    <p class="desc">단일 표현식을 반환하는 경우에 중괄호 {}와 return 키워드를 생략할 수 있습니다. 위의 예제에서 func 함수는 중괄호 없이도 표현식의 결과가
                        반환됩니다</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                100
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple06 -->
                <div id="sample07" class="sample">
                    <h3>07. 화살표 함수 : 익명 함수</h3>
                    <p>익명 함수를 화살표 함수로 간결하게 표현합니다.</p>
                    <pre><code class="language-js">{
        const func = () => {
            const x = 700;
            console.log(x);
        }
        func();
}
</code></pre>
                    <p class="desc">익명 함수를 화살표 함수로 코드를 더 간결하게 만들 수 있습니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                700
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple07 -->
                <div id="sample08" class="sample">
                    <h3>08. 화살표 함수 : 매개변수 함수</h3>
                    <p>매개변수 함수를 화살표 함수로 간결하게 표현할 수 있습니다.</p>
                    <pre><code class="language-js">{
        function func(x){
            return x
        };
        console.log(func(100));

        const func1 = function(x){
            return x
        };
        console.log(func1(100));
}
</code></pre>
                    <p class="desc">화살표 함수는 =>를 사용하여 정의되며, function 키워드를 사용하지 않습니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                100
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple08 -->
                <div id="sample09" class="sample">
                    <h3>09. 화살표 함수 : 리턴값 함수</h3>
                    <p>리턴값 함수를 화살표 함수로 간결하게 표현할 수 있습니다.</p>
                    <pre><code class="language-js">{
        func = () => {
            const x = 900;
            return x;
        }
        console.log(func());
}
</code></pre>
                    <p class="desc">리턴값 함수를 화살표 함수로 변경할 수 있습니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                900
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple09 -->
                <div id="sample10" class="sample">
                    <h3>10. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값</h3>
                    <p>화살표 함수는 주로 익명 함수나 간단한 작업을 처리할 때 사용되며, 코드를 더 간결하게 만들어줍니다.</p>
                    <pre><code class="language-js">{
        const func = (x) => {
            return x;
        }
        document.write(func("함수가 실행되었습니다.10"));

        // 매개변수 한개일때 괄호 생략 가능
        const func2 = x => {
            return x;
        }
        document.write(func2("함수가 실행되었습니다.10-2"));

        // 리턴 생략
        const func3 = x => x;

        document.write(func3("함수가 실행되었습니다.10-3"));

        // 선언적 함수
        func4 = x => x;

        document.write(func4("함수가 실행되었습니다.10-4"));
}
</code></pre>
                    <p class="desc">익명 함수와 매개변수와 리턴값을 가진 함수를 화살표 함수로 변경했습니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                함수가 실행되었습니다.10<br>
                                함수가 실행되었습니다.10-2<br>
                                함수가 실행되었습니다.10-3<br>
                                함수가 실행되었습니다.10-4
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple10 -->
                <div id="sample11" class="sample">
                    <h3>11. 함수 유형 : 함수와 매개변수를 이용한 형태</h3>
                    <p>함수와 매개변수를 이용한 형태의 함수 예제입니다.</p>
                    <pre><code class="language-js">{
        function func(num,str){
            console.log(`${num}. ${str}`);
        }
        func(11, "함수가 실행되었습니다.")
}
</code></pre>
                    <p class="desc">
                        1. function func(num, str):<br>
                        이 부분은 func라는 이름의 함수를 정의하는 부분입니다.<br>
                        함수는 매개변수 num과 str을 받습니다.<br>
                        2. { console.log(${num}. ${str}); }<br>
                        이 부분은 함수의 몸체를 나타냅니다.<br>
                        몸체 내부에는 하나의 명령문이 포함되어 있습니다.<br>
                        console.log() 함수를 사용하여 메시지를 콘솔에 출력합니다.<br>
                        이 메시지는 문자열 템플릿 리터럴을 사용하여 구성됩니다. <br>
                        ${num}과 ${str}는 각각 함수에 전달된 num과 str 매개변수 값을 문자열로 변환하여 출력합니다.<br>
                        3. func(11, "함수가 실행되었습니다.");<br>
                        이 부분은 func 함수를 호출하는 부분입니다.<br>
                        함수 호출 시에는 인수(argument)를 전달합니다.<br>
                        여기서는 num에 11이라는 숫자를, str에 "함수가 실행되었습니다."라는 문자열을 전달합니다.<br>

                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                11. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple11 -->
                <div id="sample12" class="sample">
                    <h3> 12. 함수 유형 : 함수와 변수를 이용한 형태</h3>
                    <p>함수와 변수를 이용한 형태의 함수 예제입니다.</p>
                    <pre><code class="language-js">{
        const num = 12;
        const str = "함수가 실행되었습니다";
        
        function func(num,str){
            console.log(num + ". " + str);
            // console.log(`${num}. ${str}`);
        }
        func(num,str);
}
</code></pre>
                    <p class="desc">
                        1. num과 str 상수 변수가 선언되고 초기화됩니다.<br>
                        num은 12로 초기화되고, str은 "함수가 실행되었습니다"라는 문자열로 초기화됩니다.<br>
                        2. func라는 이름의 함수가 정의됩니다.<br>
                        이 함수는 두 개의 매개변수 num과 str을 가집니다.<br>
                        3. 함수 func 내에서 num과 str 값을 이용하여 메시지를 생성하고 콘솔에 출력합니다.<br>
                        -num과 str 값을 문자열로 결합하여 "12. 함수가 실행되었습니다" 메시지를 생성합니다.<br>
                        4. 함수 func을 호출합니다.<br>
                        호출 시에는 num과 str 변수에 저장된 값이 함수에 전달됩니다.<br>
                        5. 실행 결과는 콘솔에 출력됩니다.<br>
                        "12. 함수가 실행되었습니다"가 콘솔에 출력됩니다.<br>
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                12. 함수가 실행되었습니다
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple12 -->
                <div id="sample13" class="sample">
                    <h3>13. 함수 유형 : 함수와 배열을 이용한 형태</h3>
                    <p>함수와 배열을 사용한 형태의 함수 예제입니다.</p>
                    <pre><code class="language-js">{
        const num = [13, 14];
        const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."]
    
        function func(num,str){
            console.log(`${num}. ${str}`);
        }
        func(num[0] , str[0]);
        func(num[1] , str[1]);
}
</code></pre>
                    <p class="desc">
                        num과 str이라는 두 개의 배열을 정의합니다.<br>
                        func라는 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받아들입니다.<br>
                        함수 func 내에서 템플릿 리터럴을 사용하여 num과 str을 결합하여 콘솔에 출력합니다.<br>
                        두 번의 함수 호출을 통해 배열 num과 str의 요소를 함수에 전달하고, 각 호출에서 다른 메시지가 생성되고 콘솔에 출력됩니다.<br>
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                13. 함수가 실행되었습니다.<br>
                                14. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple13 -->
                <div id="sample14" class="sample">
                    <h3>14. 함수 유형 : 함수와 객체를 이용한 형태</h3>
                    <p>함수와 객체를 이용한 형태의 함수 예제입니다.</p>
                    <pre><code class="language-js">{
        const info = {
            num : 15,
            str : "함수가 실행되었습니다."
        }
        function func(num, str){
            console.log(`${num}. ${str}`);
        }
        func(info.num,info.str);
}
</code></pre>
                    <p class="desc">
                        info라는 객체를 생성하고 초기화합니다.<br>
                        이 객체는 num이라는 속성에 15를, str이라는 속성에 "함수가 실행되었습니다."를 가지고 있습니다.<br>
                        func라는 함수를 정의합니다.<br>

                        이 함수는 두 개의 매개변수 num과 str을 받아들입니다.<br>
                        함수 func 내에서 템플릿 리터럴을 사용하여 num과 str을 결합하여 콘솔에 출력합니다.<br>

                        func(info.num, info.str);를 호출합니다.<br>

                        info 객체의 num 속성과 str 속성 값을 함수에 전달합니다.<br>
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                15. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple14 -->
                <div id="sample15" class="sample">
                    <h3>15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</h3>
                    <p></p>
                    <pre><code class="language-js">{
        const info = [
            { num: 16, str: "함수가 실행되었습니다."},
            { num: 17, str: "함수가 실행되었습니다."},
        ];
        function func(num, str){
            console.log(`${num}. ${str}`);
        }
        func(info[0].num, info[0].str);
        func(info[1].num, info[1].str);
}
</code></pre>
                    <p class="desc">
                        1. info라는 배열을 생성하고 초기화합니다.<br>
                        이 배열은 두 개의 객체를 원소로 갖고 있습니다.<br>
                        각 객체는 num 속성에 숫자(16 또는 17)와 str 속성에 "함수가 실행되었습니다." 문자열을 가지고 있습니다.<br>
                        2. func라는 함수를 정의합니다.<br>

                        3. 이 함수는 두 개의 매개변수 num과 str을 받아들입니다.
                        함수 func 내에서 템플릿 리터럴을 사용하여 num과 str을 결합하여 콘솔에 출력합니다.

                        4. func(info[0].num, info[0].str);를 호출하여 첫 번째 객체의 속성 값을 함수에 전달합니다.

                        5. func(info[1].num, info[1].str);를 호출하여 두 번째 객체의 속성 값을 함수에 전달합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                16. 함수가 실행되었습니다.<br>
                                17. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple15 -->
                <div id="sample16" class="sample">
                    <h3>16. 함수 유형 : 객체 안에 함수를 이용한 형태</h3>
                    <p>객체 안에 함수를 이용한 형태의 함수 예제입니다.</p>
                    <pre><code class="language-js">{
        const info = {
            num: 18,
            str: "함수가 실행되었습니다.",
            result: () => console.log(`${info.num}. ${info.str}`),
        }
        info.result()
}
</code></pre>
                    <p class="desc">
                        1. info라는 상수 객체가 생성됩니다.<br>
                        2. 이 객체는 세 개의 속성을 가집니다:<br>
                        num: 18<br>
                        str: "함수가 실행되었습니다."<br>
                        result: 함수 표현식으로 정의된 익명 함수입니다. <br>
                        이 함수는 console.log를 사용하여 num과 str 속성을 조합한 문자열을 출력합니다.<br>
                        3. info.result()를 호출하여 이 함수를 실행합니다.<br>
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                18. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple16 -->
                <div id="sample17" class="sample">
                    <h3>17. 함수 유형 : 객체 생성자 함수</h3>
                    <p>생성자 함수와 객체 인스턴스를 사용하여 두 개의 객체를 만들고, 객체의 메서드를 호출하여 속성을 출력하는 예제입니다. </p>
                    <pre><code class="language-js">{
    function Func(num, str){
        this.num = num;
        this.str = str;
        this.result = () => {
            console.log(`${this.num}. ${this.str}`)
        }
    }
    // 인스턴스 생성
    const info1 = new Func(19, "함수가 실행되었습니다.");
    const info2 = new Func(20, "함수가 실행되었습니다.");

    // 호출
    info1.result();
    info2.result();
}
</code></pre>
                    <p class="desc">
                        1. Func 생성자 함수 정의: Func 생성자 함수는 num과 str 매개변수를 받아 인스턴스의 속성으로 할당하고, result 메서드를 가진 객체를 생성합니다.<br>
                        2. 객체 인스턴스 생성:<br>
                        - info1 인스턴스: Func 생성자 함수를 호출하여 num에 19, str에 "함수가 실행되었습니다." 값을 가진 객체를 생성합니다.<br>
                        - info2 인스턴스: Func 생성자 함수를 호출하여 num에 20, str에 "함수가 실행되었습니다." 값을 가진 객체를 생성합니다.<br>
                        3. 메서드 호출:<br>
                        - info1.result()를 호출하여 첫 번째 객체의 result 메서드를 실행하고, "19. 함수가 실행되었습니다."라는 문자열을 출력합니다.<br>
                        - info2.result()를 호출하여 두 번째 객체의 result 메서드를 실행하고, "20. 함수가 실행되었습니다."라는 문자열을 출력합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                19. 함수가 실행되었습니다.<br>
                                20. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple17 -->
                <div id="sample18" class="sample">
                    <h3>18. 함수 유형 : 프로토타입 함수</h3>
                    <p> JavaScript를 사용하여 객체 지향 프로그래밍(OOP)의 개념을 보여주는 예제입니다.</p>
                    <pre><code class="language-js">{
        function Func(num, str){
            this.num = num;
            this.str = str;
        }

        Func.prototype.result = function(){
            console.log(`${this.num}. ${this.str}`);
        }
        
        const info1 = new Func(21, "함수가 실행되었습니다.");
        const info2 = new Func(22, "함수가 실행되었습니다.");

        info1.result();
        info2.result();
}
</code></pre>
                    <p class="desc">
                        1. function Func(num, str):<br>
                        - 이 함수는 두 개의 매개변수 num과 str을 받는 생성자 함수입니다.<br>
                        -num은 숫자를, str은 문자열을 나타내며, 이 함수를 사용하여 객체를 생성할 때 값을 초기화하는 데 사용됩니다.<br>
                        2. this.num 및 this.str:<br>
                        - 생성자 함수 내에서 this 키워드를 사용하여 객체의 프로퍼티를 초기화합니다.<br>
                        - this.num은 생성자 함수가 받은 num 매개변수의 값을 저장하고, this.str은 str 매개변수의 값을 저장합니다.<br>
                        3. Func.prototype.result:<br>
                        - Func 생성자 함수의 프로토타입에 result 메서드를 추가합니다.<br>
                        - 이 메서드는 객체가 호출할 수 있으며, 객체의 num 및 str 속성을 출력하는 역할을 합니다.<br>
                        4. const info1 = new Func(21, "함수가 실행되었습니다.");:<br>
                        - Func 생성자 함수를 사용하여 info1 객체를 생성합니다. 이 객체는 num에 21을, str에 "함수가 실행되었습니다."를 가지고 초기화됩니다.<br>
                        5. const info2 = new Func(22, "함수가 실행되었습니다.");:<br>
                        - 마찬가지로 Func 생성자 함수를 사용하여 info2 객체를 생성합니다. 이 객체는 num에 22를, str에 "함수가 실행되었습니다."를 가지고 초기화됩니다.<br>
                        6. info1.result();:<br>
                        - info1 객체의 result 메서드를 호출합니다.<br>
                        - 이 메서드는 객체의 num과 str 값을 출력합니다. 따라서 "21. 함수가 실행되었습니다."가 콘솔에 출력됩니다.<br>
                        7. info2.result();:<br>
                        - 마찬가지로 info2 객체의 result 메서드를 호출합니다.<br>
                        - 이번에는 info2 객체의 num과 str 값을 출력하므로 "22. 함수가 실행되었습니다."가 콘솔에 출력됩니다.
                        <br>
                        이 코드의 주요 포인트는 객체 지향 프로그래밍의 개념 중 하나인 생성자 함수와 프로토타입을 사용하여 객체를 생성하고 메서드를 공유하는 방법을 보여줍니다. 생성자 함수를
                        사용하여 객체를 초기화하고, 프로토타입을 활용하여 모든 객체가 공통으로 사용할 수 있는 메서드를 정의합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                21. 함수가 실행되었습니다.<br>
                                22. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple18 -->
                <div id="sample19" class="sample">
                    <h3> 19. 함수 유형 : 객체 리터럴 함수</h3>
                    <p>JavaScript를 사용하여 객체 지향 프로그래밍(OOP)의 개념을 보여주는 예제입니다.</p>
                    <pre><code class="language-js">{
        function Func(num, str){
            this.num = num;
            this.str = str;
        }

        Func.prototype = {
            result1 : function(){
                console.log(`${this.num}. ${this.str}`);
            },
            result2 : function(){
                console.log(`${this.num}. ${this.str}`);
            },
        }

        const info1 = new Func(23, "함수가 실행되었습니다.");
        const info2 = new Func(24, "함수가 실행되었습니다.");

        info1.result1();
        info2.result2();
}
</code></pre>
                    <p class="desc">
                        1. function Func(num, str):<br>
                        - 이 함수는 두 개의 매개변수 num과 str을 받는 생성자 함수입니다.<br>
                        - num은 숫자를, str은 문자열을 나타내며, 이 함수를 사용하여 객체를 생성할 때 값을 초기화하는 데 사용됩니다.<br>
                        2. this.num 및 this.str:<br>
                        - 생성자 함수 내에서 this 키워드를 사용하여 객체의 프로퍼티를 초기화합니다.<br>
                        - this.num은 생성자 함수가 받은 num 매개변수의 값을 저장하고, this.str은 str 매개변수의 값을 저장합니다.<br>
                        3. Func.prototype 객체:<br>
                        - Func.prototype 객체를 정의하여 생성자 함수 Func의 프로토타입을 설정합니다.<br>
                        - 이 프로토타입 객체는 두 개의 메서드인 result1과 result2를 가집니다.<br>
                        4. result1 메서드:<br>
                        - result1 메서드는 객체의 num과 str 값을 출력하는 역할을 합니다.<br>
                        - ${this.num}. ${this.str}를 사용하여 객체의 num과 str 값을 문자열로 합쳐서 출력합니다.<br>
                        5. result2 메서드:<br>
                        - result2 메서드 역시 객체의 num과 str 값을 출력하는 역할을 합니다.<br>
                        - ${this.num}. ${this.str}를 사용하여 객체의 num과 str 값을 문자열로 합쳐서 출력합니다.<br>
                        6. 객체 생성:<br>
                        - const info1 = new Func(23, "함수가 실행되었습니다.");를 통해 Func 생성자 함수를 사용하여 info1 객체를 생성합니다. 이 객체는 num에
                        23을, str에 "함수가 실행되었습니다."를 가지고 초기화됩니다.<br>
                        - const info2 = new Func(24, "함수가 실행되었습니다.");를 통해 Func 생성자 함수를 사용하여 i nfo2 객체를 생성합니다. 이 객체는 num에
                        24를, str에 "함수가 실행되었습니다."를 가지고 초기화됩니다.<br>
                        7.메서드 호출:<br>
                        - info1.result1();을 호출하여 info1 객체의 result1 메서드를 실행합니다. 이 메서드는 "23. 함수가 실행되었습니다."라는 문자열을 콘솔에
                        출력합니다.<br>
                        - info2.result2();을 호출하여 info2 객체의 result2 메서드를 실행합니다. 이 메서드는 "24. 함수가 실행되었습니다."라는 문자열을 콘솔에
                        출력합니다.<br>
                        <br>
                        이 코드의 주요 포인트는 생성자 함수와 프로토타입을 사용하여 객체를 생성하고, 메서드를 프로토타입에 추가하여 객체들이 공통으로 사용할 수 있는 메서드를 정의하는 방법을
                        보여줍니다.<br>
                        결과적으로 두 개의 객체가 동일한 메서드를 호출하여 다른 데이터를 출력하는 것을 확인할 수 있습니다.

                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                23. 함수가 실행되었습니다.<br>
                                24. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple19 -->
                <div id="sample20" class="sample">
                    <h3>20. 함수 : 즉시실행 함수</h3>
                    <p>익명 함수를 선언하고 즉시 실행하는 예시입니다. 이렇게 익명 함수를 생성하고 즉시 실행하는 패턴은 주로 데이터 보호 및 스코프 제한을 위해 사용됩니다.</p>
                    <pre><code class="language-js">{
        (function () {
            console.log("25.함수가 실행되었습니다.");
        })();

        (() => {
            console.log("26.함수가 실행되었습니다.");
        })();
}</code></pre>
                    <p class="desc">
                        1.(function () { console.log("25.함수가 실행되었습니다."); })(); - 이 코드는 익명 함수를 선언하고 즉시 실행합니다. 이 함수는 console.log를 사용하여 "25.함수가 실행되었습니다."라는 메시지를 콘솔에 출력합니다. 이 함수는 정의된 즉시 실행되므로 스크립트가 로드될 때 실행됩니다.
                        <br><br>
                        2.(() => { console.log("26.함수가 실행되었습니다."); })(); - 이 코드는 화살표 함수를 사용하여 익명 함수를 선언하고 즉시 실행합니다. 이 함수도 console.log를 사용하여 "26.함수가 실행되었습니다."라는 메시지를 콘솔에 출력합니다. 화살표 함수는 ES6(ECMAScript 2015)에서 도입된 문법으로, 함수를 간결하게 정의할 수 있습니다.
                        <br><br>
                        두 코드 모두 함수를 선언하고 즉시 실행하기 위해 괄호 (function () { /* ... */ })(); 또는 (() => { /* ... */ })();를 사용합니다. 이렇게 하면 함수가 선언되고 즉시 실행되므로 함수의 내용이 실행되고 함수는 스코프 내부로 제한됩니다. 이는 변수와 함수의 스코프를 제어하고 전역 스코프를 오염시키지 않는 데 도움이 됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                25.함수가 실행되었습니다.<br>
                                26.함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple20 -->
                <div id="sample21" class="sample">
                    <h3>21. 함수 : 파라미터 함수</h3>
                    <p></p>
<pre><code class="language-js">{
        function func(str = "27. 함수가 실행되었습니다.") {
            console.log(str);
        }
        func();

        const func1 = (str = "28. 함수가 실행되었습니다.") => {
            console.log(str);
        }
        func1();
}</code></pre>
                    <p class="desc">
                        1. function func(str = "27. 함수가 실행되었습니다.") { console.log(str); }<br>
                        - 이 코드는 func라는 이름의 함수를 선언합니다.<br>
                        - 함수는 str이라는 매개변수를 가지며, 기본값으로 "27. 함수가 실행되었습니다." 문자열을 가지고 있습니다.<br>
                        - 함수 내부에서 console.log를 사용하여 str 변수의 값을 출력합니다.<br>
                        - 함수를 호출할 때 func()와 같이 아무런 인수를 전달하지 않으면 기본값이 사용되고, "27. 함수가 실행되었습니다."가 출력됩니다.<br>

                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                27. 함수가 실행되었습니다.<br>
                                28. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple21 -->
                <div id="sample22" class="sample">
                    <h3>22. 함수 : 재귀함수 : 자기 자신을 호출하는 함수</h3>
                    <p>재귀 함수(Recursive Function)는 함수가 자기 자신을 호출하는 프로그래밍 기법입니다. <br>
                        재귀 함수는 일반적인 함수처럼 작동하지만, 함수 내에서 자기 자신을 호출하여 반복적으로 작업을 수행하거나 문제를 해결하는 데 사용됩니다.</p>
                    <pre><code class="language-js">{
        const func = (num) => {
            for (let i = 1; i <= num; i++) {
                console.log("29.함수가 실행되었습니다.");
            }
        }
        func(10);

        function func1(num) {
            if (num < 1) return;

            console.log("30.함수가 실행되었습니다.");
            func1(num - 1);
        }
        func1(10);
}</code></pre>
                    <p class="desc">
                        func 함수는 반복문을 사용하여 num이 주어진 횟수(여기서는 10)만큼 메시지를 출력합니다.<br><br>
                        func1 함수는재귀 함수로서, num이 1보다 작아질 때까지 "30.함수가 실행되었습니다."를 출력하고,<br>
                         num을 1씩 감소시킨 다음 자기 자신을 다시 호출합니다. <br>
                        이것은 func1 함수가 10번 호출되며 각 호출에서 1씩 감소한 num을 가지며 메시지를 출력하게 됩니다.<br>
                        따라서 이 코드는 func 함수와 func1 함수 두 가지 방법으로 10번씩 메시지를 출력하는 것을 보여줍니다. <br>
                        func 함수는 반복문을 사용하고, func1 함수는 재귀를 사용하여 동일한 결과를 얻습니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                29.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                                30.함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple22 -->
                <div id="sample23" class="sample">
                    <h3>23. 콜백 함수 : 다른 함수로 실행되는 함수</h3>
                    <p>콜백 함수(Callback Function)는 JavaScript에서 매우 일반적으로 사용되는 개념으로, <br>
                        함수를 다른 함수의 인수로 전달하고 나중에 실행하는 함수를 가리킵니다.<br>
                         콜백 함수는 비동기 작업을 처리하거나 함수 간의 상호 작용을 제어하는 데 사용됩니다.</p>
                    <pre><code class="language-js">{
        // 01. 이벤트 콜백 함수
        function func() {
            console.log("31. 함수가 실행되었습니다.");
        }
        // btn.addEventListerner("click", func);

        // 02. 함수를 다른 함수의 인자로 전달
        function func1() {
            console.log("32. 함수가 실행되었습니다.")
        }
        function func2(callback) {
            callback()
            // func1();
        }
        func2(func1);

        // 03. 반복문으로 콜백함수 만들기
        function func3(num) {
            console.log(num + ". 함수가 실행되었습니다.");
        }
        function func4(callback) {
            for (let i = 33; i <= 38; i++) {
                callback(i);
            }
        }
        func4(func3);
}</code></pre>
                    <p class="desc">
                        이벤트 콜백 함수:
첫 번째 부분에서는 func라는 함수를 정의하고 있습니다.<br>
주석 처리된 btn.addEventListener("click", func) 부분에서 func 함수가 "click" 이벤트에 연결되어 클릭할 때 실행되도록 설정할 수 있습니다.<br><br>
함수를 다른 함수의 인자로 전달: 두 번째 부분에서는 func1 함수를 정의하고 func2 함수를 호출하는데,<br>
 func2 함수는 콜백 함수를 인자로 받아 실행합니다. <br>
 func1 함수가 func2 함수에 전달되어 func2 함수 내부에서 호출됩니다. <br>
 따라서 func2 함수가 실행되면 func1 함수도 실행됩니다.<br><br>
반복문으로 콜백 함수 만들기: 세 번째 부분에서는 func3 함수와 func4 함수를 정의하고 있습니다.<br>
 func4 함수는 인자로 콜백 함수를 받아서 반복문을 사용하여 해당 콜백 함수를 여러 번 호출합니다. <br>
 구체적으로 func3 함수가 func4 함수에 전달되고, func4 함수는 func3 함수를 33부터 38까지 6번 호출합니다. <br>
 따라서 "33. 함수가 실행되었습니다."부터 "38. 함수가 실행되었습니다."까지 6개의 메시지가 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                32. 함수가 실행되었습니다.<br>
                                33. 함수가 실행되었습니다.<br>
                                34. 함수가 실행되었습니다.<br>
                                35. 함수가 실행되었습니다.<br>
                                36. 함수가 실행되었습니다.<br>
                                37. 함수가 실행되었습니다.<br>
                                38. 함수가 실행되었습니다.<br>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple23 -->
                <div id="sample24" class="sample">
                    <h3>24. 함수 : 비동기 함수 </h3>
                    <p>비동기 함수(Asynchronous Function)는 동기 함수와 달리 실행이 끝날 때까지 대기하지 않고 다른 작업을 수행할 수 있는 함수를 가리킵니다.<br>
                        비동기 함수는 주로 네트워크 요청, 파일 읽기/쓰기, 타임아웃 설정 및 이벤트 핸들링과 같이 시간이 오래 걸리거나 외부 요인에 의해 실행 시간이 예측할 수 없는 작업을 다루는 데 사용됩니다.</p>
                    <pre><code class="language-js">{
        //01. 동기적인 함수 호출
        function func1() {
            console.log("39. 함수가 실행되었습니다.");
        }
        function func2() {
            console.log("40. 함수가 실행되었습니다.");
        }
        func1();
        func2();


        // 02. 비동기적인 함수 호출
         function func3(){
             setTimeout(()=>{
                 console.log("41. 함수가 실행되었습니다.");
             },1000);
         }
         function func4(){
             console.log("42. 함수가 실행되었습니다.");
         }
         func3();
         func4();

         // 03. 비동기적인 콜백함수 호출
         function func5(callback){
             setTimeout(()=>{
                 console.log("43. 함수가 실행되었습니다.");
                 callback();
             },1000);
         }
         function func6(){
             console.log("44. 함수가 실행되었습니다.");
         }
         func5(function(){func6();});

         콜백 지옥
             {
                 function funcA(callback){
                     setTimeout(()=>{
                         console.log("funcA가 실행되었습니다.");
                         callback();
                     },1000);
                 }
                 function funcB(callback){
                     setTimeout(()=>{
                         console.log("funcB가 실행되었습니다.");
                         callback();
                     },1000);
                 }
                 function funcC(callback){
                     setTimeout(()=>{
                         console.log("funcC가 실행되었습니다.");
                         callback();
                     },1000);

                 }
                 function funcD(){
                     setTimeout(()=>{
                         console.log("funcD가 실행되었습니다.");
                     },1000);
                 }
                 funcA(function(){
                     funcB(function(){
                         funcC(function(){
                             funcD();
                         })
                     })
                 });
             }
}</code></pre>
                    <p class="desc">
                        1. 동기적인 함수 호출:<br>
                            func1 함수가 호출되고 "39. 함수가 실행되었습니다."가 출력됩니다.<br>
                            그 다음, func2 함수가 호출되고 "40. 함수가 실행되었습니다."가 출력됩니다.<br>
                            함수들은 순차적으로 실행되며, 다른 함수의 실행을 기다립니다.<br><br>

                        2. 비동기적인 함수 호출:<br>
                            func3 함수는 setTimeout을 사용하여 1초 후에 실행되며, "41. 함수가 실행되었습니다."가 출력됩니다.<br>
                            func4 함수는 func3 함수와 별도로 호출되며, "42. 함수가 실행되었습니다."가 출력됩니다.<br>
                            func3 함수는 비동기적으로 실행되므로 다른 코드의 실행을 차단하지 않습니다.<br><br>
                            
                        3. 비동기적인 콜백 함수 호출:<br>
                            func5 함수는 setTimeout을 사용하여 1초 후에 실행되며, "43. 함수가 실행되었습니다."가 출력됩니다. 그런 다음, callback 함수가 호출됩니다.<br>
                            func6 함수는 func5 함수 내부에서 콜백 함수로 전달되고 실행됩니다. "44. 함수가 실행되었습니다."가 출력됩니다.<br>
                            이것은 비동기적인 콜백 함수 호출의 예시로, 한 함수가 완료될 때까지 다른 코드의 실행을 차단하지 않습니다.<br><br>
                        4. 콜백 지옥:<br>
                            이 부분에서는 funcA, funcB, funcC, 그리고 funcD 함수가 순차적으로 호출되며, 각 함수는 이전 함수의 완료 후에 실행됩니다.<br>
                            이 코드 스타일은 콜백 함수를 중첩하여 사용하고 있어 가독성이 나쁘며, "콜백 지옥"이라고 불리는 상황을 나타냅니다. 이를 해결하기 위해 Promise, async/await, 또는 다른 비동기 제어 패턴을 사용할 수 있습니다.<br>
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                39. 함수가 실행되었습니다.<br>
                                40. 함수가 실행되었습니다.<br>

                                42. 함수가 실행되었습니다.<br>
                                41. 함수가 실행되었습니다.<br>

                                43. 함수가 실행되었습니다.<br>
                                44. 함수가 실행되었습니다.<br>

                                funcA가 실행되었습니다.<br>
                                funcB가 실행되었습니다.<br>
                                funcC가 실행되었습니다.<br>
                                funcD가 실행되었습니다.<br>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple24 -->
                <div id="sample25" class="sample">
                    <h3>25. 함수 : 비동기 함수 : 프로미스</h3>
                    <p>프로미스(Promise)는 JavaScript에서 비동기 작업을 처리하고 관리하기 위한 객체입니다. 프로미스는 특히 비동기 코드를 보다 구조화하고 가독성 있게 만들며, 오류 처리와 비동기 작업의 흐름 관리를 개선하는 데 도움이 됩니다.</p>
                    <pre><code class="language-js">{
        let data = true;

        const func = new Promise((resolve, reject) => {
            if(data){
                resolve("45. 함수가 실행되었습니다.");
            }else {
                reject("45. 함수가 실행되지 않았습니다.");
            }
        });

        func
            .then(
                result => console.log(result)
            )
            .catch (
                error => console.log(error)
            )
    //콜백지옥 -> 프로미스
        function funcA(){
            return new Promise((resolve) => {
                setTimeout(()=> {
                    console.log("funcA가 실행되었습니다.");
                    resolve();
                },1000);
            })
        }

        function funcB(){
            return new Promise((resolve) => {
                setTimeout(()=> {
                    console.log("funcB가 실행되었습니다.");
                    resolve();
                },1000);
            })
        }

        function funcC(){
            return new Promise((resolve) => {
                setTimeout(()=> {
                    console.log("funcC가 실행되었습니다.");
                    resolve();
                },1000);
            })
        }

        function funcD(){
            return new Promise((resolve) => {
                setTimeout(()=> {
                    console.log("funcD가 실행되었습니다.");
                    resolve();
                },1000);
            })
        }
        funcA().then(funcB).then(funcC).then(funcD).catch((error) => {
            console.log(error);
        })
}</code></pre>
                    <p class="desc">
                        첫 번째 프로미스 (func):<br>
func라는 이름의 프로미스가 정의되었습니다.<br>
 이 프로미스는 data 변수가 true인 경우 resolve를 호출하여 "45. 함수가 실행되었습니다."를 반환합니다.<br>
  그렇지 않으면 reject를 호출하여 "45. 함수가 실행되지 않았습니다."를 반환합니다.<br>
.then 메소드를 사용하여 프로미스가 성공할 경우 결과를 출력합니다.<br>
.catch 메소드를 사용하여 프로미스가 실패할 경우 오류를 출력합니다. <br>
이 부분에서는 data 변수가 true이므로 resolve가 호출되어 .then 블록이 실행되고 "45. 함수가 실행되었습니다."가 출력됩니다.<br><br>
프로미스 체인:<br>
funcA, funcB, funcC, 그리고 funcD 함수들은 각각 프로미스를 반환합니다. <br>
각 프로미스는 setTimeout 함수를 사용하여 1초 후에 실행되며, 해당 함수가 실행될 때 "funcX가 실행되었습니다." 메시지를 출력하고 resolve를 호출합니다.<br>
.then 메소드를 사용하여 프로미스 체인을 생성하고, 각 프로미스가 성공적으로 완료되면 다음 프로미스가 실행됩니다.<br>
 이로 인해 "funcA가 실행되었습니다.", "funcB가 실행되었습니다.", "funcC가 실행되었습니다.", "funcD가 실행되었습니다."가 차례로 출력됩니다.<br>
만약 어느 하나의 프로미스라도 reject가 호출되면 .catch 블록에서 오류를 처리합니다.<br>
이러한 방식으로 프로미스를 사용하면 비동기 코드를 더 직관적이고 구조화된 방식으로 작성할 수 있으며, 콜백 함수를 중첩하지 않고도 비동기 작업을 순차적으로 실행할 수 있습니다.<br>
 프로미스는 비동기 프로그래밍에서 매우 유용한 도구 중 하나이며, 오류 처리와 복잡한 비동기 흐름 관리를 더 쉽게 만들어줍니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                45. 함수가 실행되었습니다.<br>
                                funcA가 실행되었습니다.<br>
                                funcB가 실행되었습니다.<br>
                                funcC가 실행되었습니다.<br>
                                funcD가 실행되었습니다.<br>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple25 -->
                <div id="sample26" class="sample">
                    <h3>26. 함수 : 비동기 함수 : asyne/await</h3>
                    <p>async/await는 JavaScript에서 비동기 코드를 보다 간결하고 가독성이 좋게 작성할 수 있게 해주는 기능입니다. </p>
                    <pre><code class="language-js">{       
        // 01
        function func() {
            console.log("46. 함수가 실행되었습니다.");
        }
        func();

        // 02
        async function func2() {
            console.log("47. 함수가 실행되었습니다.");
        }
        func2();

        // 03
        async function func3() {
            const result = await fetch("https://webstoryboy.github.io/webstoryboy/w_json/gineungsaShort.json")
            const data = await result.json();
            console.log(data);
        }
        func3();

        // 04
        async function func4() {
            try {
                const result = await fetch("https://webstoryboy.github.io/webstoryboy/w_json/gineungsaShort.json")
                const data = await result.json();
                console.log(data);
            } catch (error){
                console.log(error);
            }
        }
        func4();
}</code></pre>
                    <p class="desc">
                        1. 동기 함수 호출:<br>
                        func 함수는 동기 함수로 정의되어 있으며, 호출되면 즉시 실행되어 "46. 함수가 실행되었습니다."를 출력합니다.<br><br>

                        2. 비동기 함수 호출:<br>
                        func2 함수는 async 키워드를 사용하여 비동기 함수로 정의되어 있습니다.<br> 
                        이 함수는 await 없이 작성되었지만 여전히 비동기 함수로 간주됩니다.<br>
                        호출되면 즉시 실행되어 "47. 함수가 실행되었습니다."를 출력합니다.<br><br>

                        3.비동기 함수 호출 및 웹 요청 (func3):<br>
                        - func3 함수는 async 키워드를 사용하여 비동기 함수로 정의되었습니다.<br>
                        - await fetch("https://webstoryboy.github.io/webstoryboy/w_json/gineungsaShort.json") 코드를 통해 웹에서 데이터를 비동기적으로 가져옵니다.<br>
                        - 그 다음, result.json()을 사용하여 JSON 데이터를 파싱하고, 결과를 data 변수에 저장합니다.<br>
                        - 마지막으로 data를 출력합니다.<br><br>

                        4.비동기 함수 호출, 웹 요청 및 오류 처리 (func4):<br>
                        - func4 함수는 func3와 비슷하게 비동기 함수로 정의되었으며, 웹에서 데이터를 가져옵니다.<br>
                        - 그러나 이 코드는 오류 처리를 추가로 포함하고 있습니다. <br>
                        try 블록 내에서 웹 요청과 JSON 파싱을 시도하고, 오류가 발생하면 catch 블록에서 해당 오류를 처리하고 출력합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                46. 함수가 실행되었습니다.<br>
                                47. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple26 -->
                <div id="sample27" class="sample">
                    <h3></h3>
                    <p></p>
                    <pre><code class="language-js">{
}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple27 -->
                <div id="sample28" class="sample">
                    <h3></h3>
                    <p></p>
                    <pre><code class="language-js">{
}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple28 -->
                <div id="sample29" class="sample">
                    <h3></h3>
                    <p></p>
                    <pre><code class="language-js">{
}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple29 -->
                <div id="sample30" class="sample">
                    <h3></h3>
                    <p></p>
                    <pre><code class="language-js">{
}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //smaple30 -->
            </div>
        </main>
        <!--//main -->

        <footer id="footer">
            <a href="mailto:elese0821@naver.com">elese0821@naver.com</a>
        </footer>
        <!-- //footer -->

    </div>
    <!-- //wrap -->

    <!-- script -->
    <script src="../assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

</body>

</html>